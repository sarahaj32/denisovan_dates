---
title: "Analysis of classifying EAS fragments by their affinity to sequenced Archaics"
output:
  html_document:
    df_print: paged
---

Goal: Investigate how much of each Denisovan introgressed component we can recover from EAS individuals, individually and combined. Determine how much overlaps between affinity groups

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/global/scratch/p2p3/pl1_moorjani/sarahj32/denisova_dating")
rm(list = ls())

library(tidyverse)
library(data.table)

# set plotting settings and variables
theme_set(theme_bw() +
            theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)))

# all files are in qc_checks/synthetic_EAS
# and were generated by fragments.sh within that same directorys
```


```{r}
# read in data (merged fragments across both chromosomes of each individual)
dat <- read.table("qc_checks/synthetic_EAS/EAS_indiv_fragment_summary", header = T)
# add on columns of interest:
dat$SJ_den <- dat$high + dat$low
dat$classified <- dat$high + dat$low + dat$nea
```


```{r}
# calculate summary statistics
class_sums <- dat %>% 
  pivot_longer(cols = c(high, low, nea, archaic, LS_nea, LS_den, SJ_den, classified)) %>% 
  group_by(pop, name) %>% 
  summarize(mean = mean(value), min = mean - sd(value), max = mean + sd(value)) %>% 
  ungroup()
```
First,plot the amount of archaic ancestry that we recover from each individual in EAS
These 
```{r}
# first plot all of the individuals and their archaic ancestry, using Laurits' thresholds
p <- dat %>% 
  pivot_longer(cols = c(LS_den, LS_nea)) %>% 
  ggplot(aes(x = reorder(indiv, value), y = value / 1000000, fill = name)) +
    geom_bar(stat = "identity", position = "stack") +
    labs(y = "Amount (in Mb)", x = "Individual", title = "Fragments classified by greatest # of matching SNPs") +
    theme_bw() +
    theme(axis.text.x = element_blank())
plot(p)

# then use my affinity classifications
p <- dat %>% 
  pivot_longer(cols = c(high, low, nea)) %>% 
  ggplot(aes(x = reorder(indiv, classified), y = value / 1000000, fill = name)) +
    geom_bar(stat = "identity", position = "stack") +
    labs(y = "Amount (in Mb)", x = "Individual", title = "Fragments classified by affinity thresholds") +
    theme_bw() +
    scale_fill_manual(values = c("darkviolet", "violet", "darkorange")) +
    theme(axis.text.x = element_blank()) +
  facet_grid(~pop, scales = "free_x")
plot(p)

p <- ggplot(class_sums, aes(x = pop, y = mean / 1000000, fill = pop)) +
  geom_bar(stat = "identity") +
  labs(y = "Amount (in Mb)") +
  geom_errorbar(aes(ymin = min / 1000000, ymax = max / 1000000)) +
  theme_bw() +
  labs(y = "Amount (in Mb)", x = "Individual", title = "Fragments classified by greatest # of matching SNPs") +
  theme(axis.title.x = element_blank()) +
  facet_wrap(~name, scales = "free_y")
plot(p)
```

Look at how the two metrics compare
```{r}
ggplot(dat, aes(x = archaic, y = classified, color = pop)) +
  geom_point() +
  theme_bw()

ggplot(dat, aes(x = LS_den, y = SJ_den, color = pop)) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0) +
  theme_bw()
```
Use cumulative plots to represent how much we can recover. Results were generated using get_cumulative.R

```{r}
cum_high <- read.table("qc_checks/synthetic_EAS/EAS_fragments_snps10_08_merged_Dhigh_cumulative.txt", header = T)
cum_high$class <- "high"
cum_low <- read.table("qc_checks/synthetic_EAS/EAS_fragments_snps10_08_merged_Dlow_cumulative.txt", header = T)
cum_low$class <- "low"

cumsum <- rbind(cum_high, cum_low)
ggplot(cumsum, aes(x = ind, y = amount / 1000000, color = class)) +
  scale_color_manual(values = c("darkviolet", "violet", "darkorange")) +
  geom_line() +
  labs(y = "Amount (Mb)", x = "Individuals") +
  theme_bw()
```
Interestingly, there seems to be more unique per individual in the low-affinity vs high-affinity. This could just be because there is more "low" than high
and somewhat by definition the "high" is constrained to be close to the sequenced Denisova

Similarly look at accumulation of Neanderthal
```{r}
cum_nea <- read.table("qc_checks/synthetic_EAS/EAS_fragments_snps10_08_merged_Nea_cumulative.txt", header = T)
cum_nea$class <- "nea"
cumsum <- rbind(cumsum, cum_nea)

ggplot(cumsum, aes(x = ind, y = amount / 1000000, color = class)) +
  geom_line() +
  scale_color_manual(values = c("darkviolet", "violet", "darkorange")) +
  labs(y = "Amount (Mb)", x = "Individuals") +
  theme_bw()
```




Now lets look at how this changes when we merge across the entire EAS dataset
```{r}
overlap <- read.table("qc_checks/synthetic_EAS/EAS_fragment_summary", header = T)
full <- filter(overlap, grepl("EAS", name))

# first plot how much we recover

overlap <- filter(overlap, !grepl("EAS", name))
full$name <- gsub("EAS_fragments_snps10_08_merged_", "", full$name)
full <- filter(full, name != "archaic") 

full$Dhigh <- ifelse(full$name == "Dlow", overlap$total[overlap$name == "Dhigh_Dlow"] / full$total, ifelse(full$name == "Nea", overlap$total[overlap$name == "Dhigh_nea"] / full$total , 1 - (overlap$total[overlap$name == "Dhigh_Dlow"] + overlap$total[overlap$name == "Dhigh_nea"]) / full$total))
full$Dlow <- ifelse(full$name == "Dhigh", overlap$total[overlap$name == "Dhigh_Dlow"] / full$total, ifelse(full$name == "Nea", overlap$total[overlap$name == "Dlow_nea"] / full$total , 1 - (overlap$total[overlap$name == "Dhigh_nea"] + overlap$total[overlap$name == "Dlow_nea"]) / full$total))
full$Nea <- ifelse(full$name == "Dhigh", overlap$total[overlap$name == "Dhigh_nea"] / full$total, ifelse(full$name == "Dlow", overlap$total[overlap$name == "Dlow_nea"] / full$total , 1 - (overlap$total[overlap$name == "Dhigh_Dlow"] + overlap$total[overlap$name == "Dlow_nea"]) / full$total))

full <- full %>% select(-total)

full %>% pivot_longer(cols = c(Dhigh, Dlow, Nea), names_to = "Overlap") %>% 
ggplot(aes(x = Overlap, y = name, fill = value)) +
  geom_tile(color = "white") +
  geom_text(aes(label = round(value, 2)), size = 3) +
  scale_fill_gradient(low = "white", high = "steelblue") +
  theme_minimal() +
  labs(x = "That Overlaps With", y = "Fraction of Affinity Group") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
overlap <- read.table("qc_checks/synthetic_EAS/EAS_fragment_summary", header = T)
full <- filter(overlap, grepl("EAS", name))

# first plot how much we recover

overlap <- filter(overlap, !grepl("EAS", name))
full$name <- gsub("EAS_fragments_snps10_08_merged_", "", full$name)
full <- filter(full, name != "archaic") 

full$Dhigh <- ifelse(full$name == "Dlow", overlap$total[overlap$name == "Dhigh_Dlow"], ifelse(full$name == "Nea", overlap$total[overlap$name == "Dhigh_nea"],  full$total[full$name == "Dhigh"] - (overlap$total[overlap$name == "Dhigh_Dlow"] + overlap$total[overlap$name == "Dhigh_nea"])))
full$Dlow <- ifelse(full$name == "Dhigh", overlap$total[overlap$name == "Dhigh_Dlow"], ifelse(full$name == "Nea", overlap$total[overlap$name == "Dlow_nea"], full$total[full$name == "Dlow"] - (overlap$total[overlap$name == "Dhigh_nea"] + overlap$total[overlap$name == "Dlow_nea"])))
full$Nea <- ifelse(full$name == "Dhigh", overlap$total[overlap$name == "Dhigh_nea"], ifelse(full$name == "Dlow", overlap$total[overlap$name == "Dlow_nea"],  full$total[full$name == "Nea"] - (overlap$total[overlap$name == "Dhigh_Dlow"] + overlap$total[overlap$name == "Dlow_nea"]) ))

full <- full %>% select(-total)

full %>% pivot_longer(cols = c(Dhigh, Dlow, Nea), names_to = "Overlap") %>% 
ggplot(aes(x = Overlap, y = name, fill = value)) +
  geom_tile(color = "white") +
  geom_text(aes(label = round(value, 2)), size = 3) +
  scale_fill_gradient(low = "white", high = "steelblue") +
  theme_minimal() +
  labs(x = "That Overlaps With", y = "Fraction of Affinity Group") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
full
```

Most of the Neanderthal fragments are unique (this makes sense because there are so many)
25-38% of the Denisovan affinity fragments overlap with each other 

